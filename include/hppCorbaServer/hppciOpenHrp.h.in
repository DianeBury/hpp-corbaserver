/*
  Research carried out within the scope of the Associated International Laboratory: Joint Japanese-French Robotics Laboratory (JRL)

  Developed by Florent Lamiraux and Mathieu Poirier (LAAS-CNRS)

*/

#ifndef HPPCI_OPENHRP_H
#define HPPCI_OPENHRP_H

#if @OPENHRP@
/*************************************
INCLUDE
**************************************/


#include <stdlib.h>
#include <map>
#include <vector>
#include <string>
#include "hppCore/hppPlanner.h"

#include "hppModel/hppHumanoidRobot.h"

KIT_PREDEF_CLASS(CkppKCDPolyhedron);

/*************************************
STRUCTURES
**************************************/

// just a declaration : the body of this class is hppciOpenHp.cpp
class CinternalCorbaObject ;

// ==============================================================================
//
//  CLASS ChppciHrpClient
//
// ==============================================================================
/** 
    \brief OpenHRP client to load HRP2 model.
*/
class ChppciOpenHrpClient {
  
  friend class CinternalCorbaObjet ;

public:

  /** 
      \brief Constructor
  */
  ChppciOpenHrpClient(ChppPlanner *hpp);

  /**
     \brief Destroy joint absolute position matrices in associative array.
  */
  ~ChppciOpenHrpClient();

  /** 
      \brief Initialize Orb and load model of HRP2 by sending a Corba request modelLoader to OpenHRP. 

      \deprecated This function is deprecated. Call loadHrp2Model(double inPenetration) instead.

      This function gets the model of HRP2 from a CORBA request and initializes a ChppProblem 
      with this robot by calling ChppPlanner::addHppProblem(CkppDeviceComponentShPtr robot).
      Note that the robot is set into half-sitting configuration.
  */
  ktStatus loadHrp2Model() __attribute__ ((deprecated));

  /** 
      \brief Initialize Orb and load model of HRP2 by sending a Corba request modelLoader to OpenHRP. 

      \param inPenetration Dynamic penetration allowed for validating direct paths of the robot.

      This function gets the model of HRP2 from a CORBA request and initializes a ChppProblem 
      with this robot by calling ChppPlanner::addHppProblem(CkppDeviceComponentShPtr robot).
      Note that the robot is set into half-sitting configuration.
  */
  ktStatus loadHrp2Model(double inPenetration);

  /**
     \brief  Initialize Orb and load model of HRP2 by sending a Corba request modelLoader to OpenHRP.
     \retval outDevice The model of HRP2 set in half-sitting position.

      Note that the robot is set into half-sitting configuration.
  */
  ktStatus loadHrp2Model(ChppHumanoidRobotShPtr &outDevice);

  /**
     \brief  Initialize Orb and load model of a robot by sending a Corba request modelLoader to OpenHRP.
     \param inFilename Name of the wrl file containing the description of the robot.
     \param inDeviceName Name of the device
     \param inOpenHrpPrefix Prefix of OpenHRP installation. Default value is provided by hppOpenHRP package.
     \retval outDevice The model of robot.

     \note The model of the robot is downloaded from "file://"+inOpenHrpPrefix+"/etc/"+inFileName

  */
  ktStatus loadRobotModel(std::string inFilename, std::string inDeviceName, ChppDeviceShPtr &outDevice, 
			  std::string inOpenHrpPrefix=std::string("@OPENHRP_PREFIX@"));

  /** 
      \brief Initialize Orb and load model of objects by sending a Corba request modelLoader to OpenHRP. 
      \param inFilename Name of the wrl file containing the description of the obstacle.
      \param inObstacleName Name of the obstacle.
      \param inOpenHrpPrefix Prefix of OpenHRP installation. Default value is provided by hppOpenHRP package.
      \retval outPolyhedron shared pointer to the polyhedron.

     \note The model of the obstacle is downloaded from "file://"+inOpenHrpPrefix+"/etc/"+inFileName

  */
  ktStatus loadObstacleModel(std::string inFilename, std::string inObstacleName, CkppKCDPolyhedronShPtr& outPolyhedron,
			     std::string inOpenHrpPrefix=std::string("@OPENHRP_PREFIX@"));
 
  /** 
      \brief Build a KineoWorks device from HRP2 model stored in Corba. 
      Once created, the device is store in hppPlanner.
      We add an extra dof in order to store time in the config.
      This enables us to build stationary linear direct paths
  */
  //ktStatus buildKppDevice(ChppDeviceShPtr& hppDevice, bool selfColFlag); 

  /**
     \brief return the pointer to planner
  */
  ChppPlanner *planner() {return hppPlanner; };

private :

  /**
     \brief Get URL of robot for loadRobotModel function.
  */
  ktStatus getRobotURL();

  /**
     \brief Get URL of obstacle for loadObstacleModel function.
  */
  ktStatus getObstacleURL(std::string inFilename);

  /** 
      \brief Pointer to Path Planner object allocated elsewhere.
  */
  ChppPlanner *hppPlanner;

  CinternalCorbaObject *privateCorbaObject ;

};

#endif
#endif
