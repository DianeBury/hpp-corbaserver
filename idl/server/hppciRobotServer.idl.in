/*
  Research carried out within the scope of the Associated International Laboratory: Joint Japanese-French Robotics Laboratory (JRL)

  Developed by Florent Lamiraux (LAAS-CNRS)

*/

#ifndef HPPCI_ROBOT_SERVER_IDL
#define HPPCI_ROBOT_SERVER_IDL

#include "hppciCommonServer.idl"

module hppCorbaServer {
  /**
   * \brief Array of joint bounds.in order [v1_min,v1_max,v2_min,v2_max,...].
   */
  typedef sequence<double> jointBoundSeq;

  /**
   * \brief Sequence of names
   */
  typedef sequence<string> nameSeq;

  /**
   * \brief Creation of a ChppDevice, joints and bodies.
   */
  interface ChppciRobot {
    /**
       \name Create and register robot
       @{
    */

    /** 
     * \brief Create an empty device and store it temporarily before adding it in object hppPlanner.
     \param inRobotName name of the robot (ChppDevice).

     * Fails if another robot is already in construction.
     */
    short createRobot(in string inRobotName);
    /** 
     * \brief Once a robot is built, add it in object ChppciServer::hppPlanner.
     * \param inRobotName name of the robot.
     * \param inPenetration dynamic penetration allowed to validate direct paths.

     * \return 0 if success, -1 if failure.
     */
    short addHppProblem(in string inRobotName, in double inPenetration);

    /**
     * \brief Set a joint as root joint to a robot.
     * \param inRobotName name of the robot (ChppDevice).
     * \param inJointName name of the joint.
     */
    short setRobotRootJoint(in string inRobotName, in string inJointName);

#if @OPENHRP@

    /**
     * \brief Load HRP2 model by sending a Corba request to OpenHRP

     * \param inPenetration dynamic penetration allowed to validate direct paths.

     Send ChppciOpenHrpClient::loadHrp2Model() request to Modelloader.

     */
    short loadHrp2Model(in double inPenetration);
#endif

    /** 
     *@}
     */

    /**
       \name Degrees of freedom
       @{
    */

    /**
       \brief Create an extra dof for inseting in a device.
       \param inDofName name of the extra dof.
       \param inRevolute whether dof is revolute.
       \param inValueMin minimal value of the dof.
       \param inValueMax maximal value of the dof.
       \note if inValueMax < inValueMin, the dof is not bounded.
    */
    short createExtraDof(in string inDofName, in boolean inRevolute, in double inValueMin, in double inValueMax);

    /**
       \brief Add an extra degree of freedom to a robot.
       \param inRobotName name of the robot.
       \param inDofName name of the extra dof
    */
    short addExtraDofToRobot(in string inRobotName, in string inDofName);

    /**
       \brief Set bound of degree of freedom
       
       \param inProblemId rank of robot in vector of robots. 
     * \param inDofId id of the degree of freedom.
       \param inMinValue, inMaxValue values of degree of freedom bounds

       \note If inMinValue > inMaxValue, dof is not bounded and bounds (for random sampling) are set to [inMaxValue, inMinValue].

    */
    short setDofBounds(in unsigned short inProblemId, in unsigned short inDofId, in double inMinValue, in double inMaxValue);

    /**
     * \brief set locking/unlocking  for the joint
     * \param inProblemId id of the problem containing the robot.
     * \param inDofId id of the degree of freedom.
     * \param locked true (locked)  false (unlocked)
     * \param lockedValue (if locked) give the value
     */
    short setDofLocked(in unsigned short inProblemId, in unsigned short inDofId, in boolean locked, in double lockedValue);

    /** \brief Get number of dof of robot in ProblemId 
	\param inProblemId rank of robot in vector of robots. 
	\param outDeviceDim TODO
    */
    short getDeviceDim(in unsigned short inProblemId, out unsigned short outDeviceDim);

    /** 
     *@}
     */

    /**
       \name Joints
       @{
    */

    /**
       \brief Create joint.
       \param inJointName name of the joint.
       \param inJointType type of joint in {"anchor", "freeflyer", "plan", "rotation", "translation"}.
       \param pos position of the joint.
       \param inJointBound sequence of joint dof bounds in order [v0_min,v0_max,v1_min,v1_max,...]. 
       \li If vi_min > vi_max, dof of rank i is not bounded and bounds (for random sampling) are set to [v_max, v_min].
       \li If size of sequence is different from twice the number of dofs, no dof is bounded.
       \param inDisplay Whether the path of the joint should be displayed in interface.

       \return 0 if success, -1 if failure.
    */
    short createJoint(in string inJointName, in string inJointType, in Configuration pos, 
		      in jointBoundSeq inJointBound, in boolean inDisplay);
    /**
     * \brief Add a child joint to a joint.
     * \param inParentName name of the joint to which a child is added.
     * \param inChildName name of the child joint added to the previous one.
     * \return 0 if success, -1 if failure.
     */
    short addJoint(in string inParentName, in string inChildName);

    /**
       \brief set a bound for the joint

       \param inJointId index of the joint in the robot.
       \param inJointBound sequence of joint dof bounds in order [v0_min,v0_max,v1_min,v1_max,...]. 
       \li If vi_min > vi_max, dof of rank i is not bounded and bounds (for random sampling) are set to [v_max, v_min].
       \li If size of sequence is different from twice the number of dofs, no dof is bounded.
       \param inProblemId Id of the problem containing the robot.
     */
    short setJointBounds(in unsigned short inProblemId, in unsigned short inJointId, in jointBoundSeq inJointBound);

    /**
     * \brief Set whether a joint is visible.

     * \param inProblemId Id of the problem containing the robot.
     * \param inJointId index of the joint in the robot.
     * \param inVisible wether the joint should be visible in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointVisible(in unsigned short inProblemId, in unsigned short inJointId, in boolean inVisible);

    /**
     * \brief Set whether a joint is transparent.

     * \param inProblemId Id of the problem containing the robot.
     * \param inJointId index of the joint in the robot.
     * \param inTransparent wether the joint should be transparent in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointTransparent(in unsigned short inProblemId, in unsigned short inJointId, in boolean inTransparent);

    /**
     * \brief Set whether paths of a joint should be displayed.

     * \param inProblemId Id of the problem containing the robot.
     * \param inJointId index of the joint in the robot.
     * \param inDisplayPath wether paths of the joint should be displayed in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointDisplayPath(in unsigned short inProblemId, in unsigned short inJointId, in boolean inDisplayPath);

    /** 
     *@}
     */

    /**
       \name Configuration
       @{
    */

    /** 
	\brief get current configuration of specified robot in ChppPlanner::robotVector.
	\param inProblemId rank of problem in vector of hppProblems.
	\return dofArray Array of degrees of freedom 
    */
    dofSeq getCurrentConfig(in unsigned short inProblemId);

#if WITH_OPENHRP
    /** 
	\brief get current configuration of specified robot in ChppPlanner::robotVector.
	\brief in the order of the joints in OpenHRP.
	\param inProblemId rank of problem in vector of hppProblems.
	\return dofArray Array of degrees of freedom in the order of joints in OpenHRP (RARM, LARM, RHAND, LHAND)
    */
    dofSeq getCurrentConfigOpenHRP(in unsigned short inProblemId);

    /** \brief set current configuration of specified robot in ChppPlanner::robotVector
	\brief in the order of the joints in OpenHRP.
	\param inProblemId rank of problem in vector of hppProblems.
	\param dofArray Array of degrees of freedom in the order of joints in OpenHRP (RARM, LARM, RHAND, LHAND)
    */
    short setCurrentConfigOpenHRP(in unsigned short inProblemId, in dofSeq dofArray);

#endif

    /** \brief set current configuration of specified robot in ChppPlanner::robotVector.
	\param inProblemId rank of problem in vector of hppProblems.
	\param dofArray Array of degrees of freedom */
    short setCurrentConfig(in unsigned short inProblemId, in dofSeq dofArray);

    /** 
     *@}
     */


    /**
       \name Bodies
       @{
    */

    /**
     * \brief Attach body to joint.
     * \param inJointName name of the joint to which the body is attached.
     * \param inBodyName name of the body.
     * \return 0 if success, -1 if failure.
     */
    short attachBodyToJoint(in string inJointName, in string inBodyName);
  
    /**
     * \brief Create a body of given name.
     * \return 0 if success, -1 if failure.
     */
    short createBody(in string inBodyName);

    /**
       \brief Get the list of object attached to a body.
       \param inBodyName name of the body.
       \return list of names of KCDobject attached to the body.
    */
    nameSeq getBodyInnerObject(in string inBodyName);

    /**
       \brief Get the list of object tested for collision with a body.
       \param inBodyName name of the body.
       \return list of names of KCDobject that are tested for collision with the body.
    */
    nameSeq getBodyOuterObject(in string inBodyName);

    /** 
     *@}
     */

    /**
       \name Collision checking
       @{
    */

    /**
       \brief Set dynamic penetration of robot

       \param inProblemId index of problem owning the robot
       \param inPenetration dynamic penetration
       \return 0 is success, -1 if error.

       Dynamic penetration is the penetration allowed when checking a
       path for collision.

       \note setting this parameter equal to the \link
       hppCorbaServer::ChppciProblem::setObstacleTolerance tolerance\endlink of
       obstacles ensures that paths will be collision-free.
    */
    short setPenetration(in unsigned short inProblemId, in double inPenetration);

    /**
       \brief Set dynamic penetration of robot

       \param inProblemId index of problem owning the robot.
       \retval outPenetration dynamic penetration.
       \return 0 is success, -1 if error.

       Dynamic penetration is the penetration allowed when checking a
       path for collision.

       \note setting this parameter equal to the \link
       hppCorbaServer::ChppciProblem::setObstacleTolerance tolerance\endlink of
       obstacles ensures that paths will be collision-free.
    */
    short getPenetration(in unsigned short inProblemId, out double outPenetration);

    /** 
	\brief Check whether the link is colliding.

	\param inProblemId index of problem owning the robot
	\param inJointId index of the joint in robot
	\retval outResult -1
    */
    short checkLinkCollision(in unsigned short inProblemId, in unsigned short inJointId, 
			     out unsigned short outResult);

    /** 
     *@}
     */

    /**
       \name Polyhedra
       @{
    */

    /**
     * \brief create an empty polyhedron.
     * \param inPolyName name of the polyhedron.
     * \return 0 if success, -1 if failure.
     */
    short createPolyhedron(in string inPolyName);
    /**
       \brief Create a box
       \param inBoxName name of the box
       \param x, y, z Size of the box
    */
    short createBox(in string inBoxName, in double x, in double y, in double z);
    /**
     * \brief Add a point to a polyhedron
     * \param inPolyName the name of the polyhedron.
     * \param x coordinate of the point. 
     * \param y coordinate of the point. 
     * \param z coordinate of the point. 
     * \return rank of point in polyhedron or -1 if failure.
     */
    short addPoint(in string inPolyName, in double x, in double y, in double z);
    /**
     * \brief Add a point to a polyhedron
     * \param inPolyName the name of the polyhedron.
     * \param pt1 rank of first point in polyhedron. 
     * \param pt2 rank of second point in polyhedron. 
     * \param pt3 rank of third point in polyhedron. 
     * \return rank of triangle in polyhedron or -1 if failure.
     */
    short addTriangle(in string inPolyName, in unsigned long pt1, 
	in unsigned long pt2, in unsigned long pt3);

    /**
       \brief Attach a polyhedron to a body.

       \param inBodyName name of the body
       \param inPolyhedronName name of the polyhedron
       \param inConfig relative position of the polyhedron in the body

       \note The body must be attached to a joint.
    */

    short addPolyToBody(in string inBodyName, in string inPolyhedronName, in Configuration inConfig);
    /** 
     *@}
     */
  };
};
#endif
