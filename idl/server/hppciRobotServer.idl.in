/*
  Research carried out within the scope of the Associated International Laboratory: Joint Japanese-French Robotics Laboratory (JRL)

  Developed by Florent Lamiraux (LAAS-CNRS)

*/

#ifndef HPPCI_ROBOT_SERVER_IDL
#define HPPCI_ROBOT_SERVER_IDL

#include "hppciCommonServer.idl"

module hppCorbaServer {
  /**
   * \brief Array of joint bounds.in order [v1_min,v1_max,v2_min,v2_max,...].
   */
  typedef sequence<double> jointBoundSeq;

  /**
   * \brief Sequence of names
   */
  typedef sequence<string> nameSeq;

  /**
   * \brief Creation of a ChppDevice, joints and bodies.
   */
  interface ChppciRobot {
    /**
       \name Create and register robot
       @{
    */

    /** 
     * \brief Create an empty device and store it temporarily before adding it in object hppPlanner.
     \param inRobotName name of the robot (ChppDevice).

     * Fails if another robot is already in construction.
     */
    short createRobot(in string inRobotName);
    /** 
     * \brief Once a robot is built, add it in object ChppciServer::hppPlanner.
     * \param inRobotName name of the robot.
     * \return 0 if success, -1 if failure.
     */
    short addHppProblem(in string inRobotName);

    /**
     * \brief Set a joint as root joint to a robot.
     * \param inRobotName name of the robot (ChppDevice).
     * \param inJointName name of the joint.
     */
    short setRobotRootJoint(in string inRobotName, in string inJointName);

#if @OPENHRP@

    /**
     * \brief Load HRP2 model by sending a Corba request to OpenHRP
     *
     */
    short loadHrp2Model();
#endif

    /** 
     *@}
     */

    /**
       \name Degrees of freedom
       @{
    */

    /**
       \brief Create an extra dof for inseting in a device.
       \param inDofName name of the extra dof.
       \param inRevolute whether dof is revolute.
       \param inValueMin minimal value of the dof.
       \param inValueMax maximal value of the dof.
       \note if inValueMax < inValueMin, the dof is not bounded.
    */
    short createExtraDof(in string inDofName, in boolean inRevolute, in double inValueMin, in double inValueMax);

    /**
       \brief Add an extra degree of freedom to a robot.
       \param inRobotName name of the robot.
       \param inDofName name of the extra dof
    */
    short addExtraDofToRobot(in string inRobotName, in string inDofName);

    /** \brief Get number of dof of robot in ProblemId 
	\param problemId rank of robot in vector of robots. 
	\param deviceDim TODO
    */
    short getDeviceDim(in short problemId, out short deviceDim);

    /** 
     *@}
     */

    /**
       \name Joints
       @{
    */

    /**
       \brief Create joint.
       \param inJointName name of the joint.
       \param inJointType type of joint in {"anchor", "freeflyer", "plan", "rotation", "translation"}.
       \param pos position of the joint.
       \param inJointBound sequence of joint dof bounds in order [v0_min,v0_max,v1_min,v1_max,...]. 
       \li If vi_min > vi_max, dof of rank i is not bounded and bounds (for random sampling) are set to [v_max, v_min].
       \li If size of sequence is different from twice the number of dofs, no dof is bounded.
       \param inDisplay Whether the path of the joint should be displayed in interface.

       \return 0 if success, -1 if failure.
    */
    short createJoint(in string inJointName, in string inJointType, in Configuration pos, 
		      in jointBoundSeq inJointBound, in boolean inDisplay);
    /**
     * \brief Add a child joint to a joint.
     * \param inParentName name of the joint to which a child is added.
     * \param inChildName name of the child joint added to the previous one.
     * \return 0 if success, -1 if failure.
     */
    short addJoint(in string inParentName, in string inChildName);

    /**
       \brief set a bound for the joint

       \param jointId index of the joint in the robot.
       \param inJointBound sequence of joint dof bounds in order [v0_min,v0_max,v1_min,v1_max,...]. 
       \li If vi_min > vi_max, dof of rank i is not bounded and bounds (for random sampling) are set to [v_max, v_min].
       \li If size of sequence is different from twice the number of dofs, no dof is bounded.
       \param problemId Id of the problem containing the robot.
     */
    short setJointBounds(in short problemId, in short jointId, in jointBoundSeq inJointBound);

    /**
     * \brief Set whether a joint is visible.

     * \param problemId Id of the problem containing the robot.
     * \param jointId index of the joint in the robot.
     * \param inVisible wether the joint should be visible in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointVisible(in short problemId, in short jointId, in boolean inVisible);

    /**
     * \brief Set whether a joint is transparent.

     * \param problemId Id of the problem containing the robot.
     * \param jointId index of the joint in the robot.
     * \param inTransparent wether the joint should be transparent in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointTransparent(in short problemId, in short jointId, in boolean inTransparent);

    /**
     * \brief Set whether paths of a joint should be displayed.

     * \param problemId Id of the problem containing the robot.
     * \param jointId index of the joint in the robot.
     * \param inDisplayPath wether paths of the joint should be displayed in the interface.
     *
     * \note When running without interface, this request has no effect.
     */
    short setJointDisplayPath(in short problemId, in short jointId, in boolean inDisplayPath);

    /**
     * \brief set locking/unlocking  for the joint
     * \param problemId id of the problem containing the robot.
     * \param dofId id of the degree of freedom.
     * \param locked true (locked)  false (unlocked)
     * \param lockedValue (if locked) give the value
     */
    short setDofLocked(in short problemId, in short dofId, in boolean locked, in double lockedValue);


    /** 
     *@}
     */

    /**
       \name Configuration
       @{
    */

    /** 
	\brief get current configuration of specified robot in ChppPlanner::robotVector.
	\param inProblemId rank of problem in vector of hppProblems.
	\return dofArray Array of degrees of freedom 
    */
    dofSeq getCurrentConfig(in short inProblemId);

#if WITH_OPENHRP
    /** 
	\brief get current configuration of specified robot in ChppPlanner::robotVector.
	\brief in the order of the joints in OpenHRP.
	\param inProblemId rank of problem in vector of hppProblems.
	\return dofArray Array of degrees of freedom in the order of joints in OpenHRP (RARM, LARM, RHAND, LHAND)
    */
    dofSeq getCurrentConfigOpenHRP(in short inProblemId);

    /** \brief set current configuration of specified robot in ChppPlanner::robotVector
	\brief in the order of the joints in OpenHRP.
	\param problemId rank of problem in vector of hppProblems.
	\param dofArray Array of degrees of freedom in the order of joints in OpenHRP (RARM, LARM, RHAND, LHAND)
    */
    short setCurrentConfigOpenHRP(in short problemId, in dofSeq dofArray);

#endif

    /** \brief set current configuration of specified robot in ChppPlanner::robotVector.
	\param problemId rank of problem in vector of hppProblems.
	\param dofArray Array of degrees of freedom */
    short setCurrentConfig(in short problemId, in dofSeq dofArray);

    /** 
     *@}
     */


    /**
       \name Bodies
       @{
    */

    /**
     * \brief Attach body to joint.
     * \param inJointName name of the joint to which the body is attached.
     * \param inBodyName name of the body.
     * \return 0 if success, -1 if failure.
     */
    short attachBodyToJoint(in string inJointName, in string inBodyName);
  
    /**
     * \brief Create a body of given name.
     * \return 0 if success, -1 if failure.
     */
    short createBody(in string inBodyName);

    /**
       \brief Get the list of object attached to a body.
       \param inBodyName name of the body.
       \return list of names of KCDobject attached to the body.
    */
    nameSeq getBodyInnerObject(in string inBodyName);

    /**
       \brief Get the list of object tested for collision with a body.
       \param inBodyName name of the body.
       \return list of names of KCDobject that are tested for collision with the body.
    */
    nameSeq getBodyOuterObject(in string inBodyName);

    /** 
     *@}
     */

    /**
       \name Collision checking
       @{
    */
  
    /** \brief see if the link is colliding.
	\param jointId index of the joint in robot
	\param problemId TODO
	\param result TODO
    */
    short checkLinkCollision(in short problemId, in short jointId, out short result);

    /** 
     *@}
     */

    /**
       \name Polyhedra
       @{
    */

    /**
     * \brief create an empty polyhedron.
     * \param inPolyName name of the polyhedron.
     * \return 0 if success, -1 if failure.
     */
    short createPolyhedron(in string inPolyName);
    /**
       \brief Create a box
       \param inBoxName name of the box
       \param x, y, z Size of the box
    */
    short createBox(in string inBoxName, in double x, in double y, in double z);
    /**
     * \brief Add a point to a polyhedron
     * \param inPolyName the name of the polyhedron.
     * \param x coordinate of the point. 
     * \param y coordinate of the point. 
     * \param z coordinate of the point. 
     * \return rank of point in polyhedron or -1 if failure.
     */
    short addPoint(in string inPolyName, in double x, in double y, in double z);
    /**
     * \brief Add a point to a polyhedron
     * \param inPolyName the name of the polyhedron.
     * \param pt1 rank of first point in polyhedron. 
     * \param pt2 rank of second point in polyhedron. 
     * \param pt3 rank of third point in polyhedron. 
     * \return rank of triangle in polyhedron or -1 if failure.
     */
    short addTriangle(in string inPolyName, in long pt1, in long pt2, in long pt3);

    /**
       \brief Attach a polyhedron to a body.

       \param inBodyName name of the body
       \param inPolyhedronName name of the polyhedron
       \param inConfig relative position of the polyhedron in the body

       \note The body must be attached to a joint.
    */

    short addPolyToBody(in string inBodyName, in string inPolyhedronName, in Configuration inConfig);
    /** 
     *@}
     */
  };
};
#endif
