// Copyright (C) 2009, 2010 by Florent Lamiraux, Thomas Moulard, JRL.
//
// This file is part of the hpp-corbaserver.
//
// This software is provided "as is" without warranty of any kind,
// either expressed or implied, including but not limited to the
// implied warranties of fitness for a particular purpose.
//
// See the COPYING file for more information.

#ifndef HPP_CORBASERVER_PROBLEM_SERVER_IDL
# define HPP_CORBASERVER_PROBLEM_SERVER_IDL
# include <hpp/corbaserver/common.idl>

module hpp
{
  /// \brief To define and solve a path planning problem.
  interface Problem
  {
    /// \name Initial and goal configurations
    /// \{

    /// Set initial configuration of specified problem.
    ///	\param dofArray Array of degrees of freedom
    ///	\return 0 if success, -1 if failure.
    short setInitialConfig (in floatSeq dofArray);

    /// Get initial configuration of specified problem.
    ///	\return Array of degrees of freedom
     floatSeq getInitialConfig ();

    /// \brief Add goal configuration to specified problem.
    ///	\param dofArray Array of degrees of freedom
    ///	\return 0 if success, -1 if failure.
    short addGoalConfig (in floatSeq dofArray);

    /// Get goal configurations of specified problem.
    ///	\return Array of degrees of freedom
    floatSeqSeq getGoalConfigs ();

    /// Reset goal configurations
    short resetGoalConfigs ();

    /// \}

    /// \name Constraints
    /// \{

    /// Apply constaints to a configuration
    ///
    /// constraints are stored in ProblemSolver object
    short applyConstraints (in floatSeq input, out floatSeq output);

    /// Reset constraints
    short resetConstraints ();

    /// Lock degree of freedom with given value
    /// \param dofId rank of the degree of freedom in configuration vector,
    /// \param value value of the locked degree of freedom.
    short lockDof (in unsigned short dofId, in double value);

    /// \}

    /// \name Solve problem and get paths
    /// \{

    // \brief Solve the problem of corresponding ChppPlanner object
    // \return 0 if success, -1 if failure.
    short solve();

    /// Make direct connection between two configurations
    /// \param startConfig, endConfig: the configurations to link.
    /// \retval message unvalidation message.
    /// \return -1 if steering method fails to create a direct path of if
    /// direct path is not valid
    short directPath (in floatSeq startConfig, in floatSeq endConfig,
		      out string message);

    /// Get Number of paths
    short numberPaths ();

    // Optimize a given path
    // \param inPathId Id of the path in this problem.
    // \return 0 if success, -1 if failure.
    short optimizePath(in unsigned short inPathId);

    // Get length of path
    // \param inPathId rank of the path in the problem
    // \return length of path if path exists, -1 otherwise
    double pathLength(in unsigned short inPathId);

     // Get the robot's config at param on the a path
     // \param inPathId rank of the path in the problem
     // \param atDistance : the user parameter choice
     // \return dofseq : the config at param
    floatSeq configAtDistance(in unsigned short inPathId, in double atDistance);

    /// \}

    /// \name Interruption of a path planning request
    /// \{

    /// \brief Interrupt path planning activity
    /// \note this request is effective only when multi-thread policy is used
    ///       by CORBA server.
    /// See constructor of class Server for details.
    short interruptPathPlanning();
    ///\}

    /// \name exploring the roadmap
    /// \{

    /// Nodes of the roadmap
    floatSeqSeq nodes ();

    /// Number of edges
    long numberEdges ();

    /// Edge at given rank
    short edge (in unsigned long edgeId, out floatSeq q1, out floatSeq q2);

    /// Number of connected components
    long numberConnectedComponents ();

    /// Nodes of a connected component
    /// \param connectedComponentId index of connected component in roadmap
    /// \return list of nodes of the connected component.
    floatSeqSeq nodesConnectedComponent (in unsigned long connectedComponentId);

    /// Clear the roadmap
    short clearRoadmap ();
    /// \}
  }; // interface Problem
}; // module hpp
#endif
