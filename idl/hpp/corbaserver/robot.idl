// Copyright (C) 2009, 2010, 2011, 2012, 1013, 2014 CNRS
// Authors:  Florent Lamiraux, Thomas Moulard.
//
// This file is part of the hpp-corbaserver.
//
// This software is provided "as is" without warranty of any kind,
// either expressed or implied, including but not limited to the
// implied warranties of fitness for a particular purpose.
//
// See the COPYING file for more information.

#ifndef HPP_CORBASERVER_ROBOT_SERVER_IDL
# define HPP_CORBASERVER_ROBOT_SERVER_IDL
# include <hpp/corbaserver/common.idl>

module hpp
{
  /// Array of joint bounds.in order [v1_min,v1_max,v2_min,v2_max,...].
  typedef sequence<double> jointBoundSeq;

  /// Sequence of names
  typedef sequence<string> nameSeq;

  /// Creation of a device, joints and bodies.
  interface Robot {
    ///  Load robot model
    ///
    /// \param modelName robot model name.
    /// \param rootJointType type of root joint among "anchor", "freeflyer",
    /// "planar",
    /// \param urdfSuffix suffix for urdf file,
    /// e.g. ${modelName}${urdfSuffix}.urdf
    ///
    /// \param srdfSuffix suffix for urdf file,
    /// e.g. ${modelName}${urdfSuffix}.srdf
    ///
    short loadRobotModel (in string rootJointType, in string modelName,
			 in string urdfSuffix, in string srdfSuffix);

    /// \}

    /// \name Degrees of freedom
    /// \{

    /// Get size of configuration
    /// \param configSize size of configuration
    short getConfigSize ();

    /// Get size of velocity
    /// \param numberDof size of velocity
    short getNumberDof ();

    /// \}

    /// \name Joints
    /// \{

    /// Get joint names in the same order as in the configuration
    nameSeq getJointNames ();

    /// Get joint number degrees of freedom
    /// \param jointName name of the joint
    /// \return -1 if robot is not set or if joint does not exist.
    short getJointNumberDof (in string jointName);

    /// Get joint number config size
    /// \param jointName name of the joint
    /// \return -1 if robot is not set or if joint does not exist.
    short getJointConfigSize (in string jointName);

    ///  set a bound for the joint

    /// \param inJointId index of the joint in the robot.
    /// \param inJointBound sequence of joint dof bounds in order
    ///        [v0_min,v0_max,v1_min,v1_max,...].
    /// \li If vi_min > vi_max, dof of rank i is not bounded and bounds
    ///     (for random sampling) are set to [v_max, v_min].
    /// \li If size of sequence is different from twice the number of dofs,
    ///     no dof is bounded.
    short setJointBounds(in unsigned short inJointId,
			 in jointBoundSeq inJointBound);

    /// \}

    /// \name Configuration
    /// \{

    /// Get current configuration
    /// \return dofArray Array of degrees of freedom.
    floatSeq getCurrentConfig();

    /// Set current configuration of specified robot,
    /// \param dofArray Array of degrees of freedom /
    short setCurrentConfig(in floatSeq dofArray);

    /// \}

    /// \name Bodies
    /// \{

    ///  Get the list of objects attached to a joint.
    /// \param inJointName name of the joint.
    /// \return list of names of CollisionObject attached to the body.
    nameSeq getJointInnerObjects (in string jointName);


    ///  Get list of collision objects tested with the body attached to a joint
    /// \param inJointName name of the joint.
    /// \return list of names of CollisionObject
    nameSeq getJointOuterObjects (in string jointName);

    /// \}

    /// \name Collision checking and distance computation
    /// \{

    /// Test collision with obstacles and auto-collision.
    ///
    /// Check whether current configuration of robot is valid by calling
    /// CkwsDevice::collisionTest ().
    /// \retval validity whether configuration is valid
    short collisionTest (out boolean validity);

    /// Compute distances between bodies and obstacles
    ///
    /// \retval distances list of distances,
    /// \retval innerObjects names of the objects belonging to a body
    /// \retval outerObjects names of the objects tested with inner objects,
    /// \retval innerPoints closest points on the body,
    /// \retval outerPoints closest points on the obstacles
    /// \note outer objects for a body can also be inner objects of another
    /// body.
    short distancesToCollision (out floatSeq distances,
				out nameSeq innerObjects,
				out nameSeq outerObjects,
				out floatSeqSeq innerPoints,
				out floatSeqSeq outerPoints);

    /// \}

    /// \name Mass and inertia
    /// \{

    /// Get mass of robot
    double getMass ();

    /// Get position of center of mass
    floatSeq getCenterOfMass ();

    /// Get Jacobian of the center of mass
    floatSeqSeq getJacobianCenterOfMass ();

    /// \}

    /// \name Create and register robot
    /// \{

    /// Create an empty device and store it temporarily
    /// \param robotName name of the robot.
    ///  Fails if another robot is already in construction.
    short createRobot(in string robotName);

    /// Create a new joint
    /// \param jointName name of the joint,
    /// \param jointType among ["anchor", "SO3", "rotation",
    ///                         "translation"]
    /// \param pos initial position of the joint
    /// \param joinBounds bounds of the joint. See setJointBounds for details.
    short createJoint(in string jointName, in string jointType,
		      in Configuration pos, in jointBoundSeq jointBounds);

    ///  Add a child joint to a joint.
    /// \param inParentName name of the joint to which a child is added.
    /// \param inChildName name of the child joint added to the previous one.
    /// \return 0 if success, -1 if failure.
    short addJoint(in string inParentName, in string inChildName);

    /// Add a robot to the ProblemSolver
    /// \return 0 if success, -1 if failure.
    short setRobot (in string inRobotName);

    ///  Set a joint as root joint to a robot.
    /// \param inRobotName name of the robot (ChppDevice).
    /// \param inJointName name of the joint.
    short setRobotRootJoint(in string inRobotName, in string inJointName);

    ///  create an empty polyhedron.
    /// \param inPolyName name of the polyhedron.
    /// \return 0 if success, -1 if failure.
    short createPolyhedron(in string inPolyName);

    ///  Create a box
    /// \param name name of the box
    /// \param x, y, z Size of the box
    short createBox (in string name, in double x, in double y, in double z);

    ///  Create a sphere
    /// \param name name of the sphere
    /// \param radius radius of the sphere
    short createSphere (in string name, in double radius);

    ///  Add a point to a polyhedron
    /// \param inPolyName the name of the polyhedron.
    /// \param x coordinate of the point.
    /// \param y coordinate of the point.
    /// \param z coordinate of the point.
    /// \return rank of point in polyhedron or -1 if failure.
    short addPoint(in string inPolyName, in double x, in double y, in double z);

    ///  Add a point to a polyhedron
    /// \param inPolyName the name of the polyhedron.
    /// \param pt1 rank of first point in polyhedron.
    /// \param pt2 rank of second point in polyhedron.
    /// \param pt3 rank of third point in polyhedron.
    /// \return rank of triangle in polyhedron or -1 if failure.
    short addTriangle(in string inPolyName, in unsigned long pt1,
		      in unsigned long pt2, in unsigned long pt3);

    ///  Attach an object to a joint.
    /// \param jointName name of the body
    /// \param objectName name of the object
    /// \param pos relative position of the polyhedron in the body
    short addObjectToJoint(in string jointName, in string objectName,
			   in Configuration pos);
    /// \}
  };
};

#endif // HPP_CORBASERVER_ROBOT_SERVER_IDL
